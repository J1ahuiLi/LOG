# 软件过程

## 能力成熟度模型（CMM）

1. 初始级：杂乱无章，混乱，无明确步骤，依赖个人和英雄式核心人物的作用
2. 可重复级别：建立了基本的项目管理过程
3. 已定义级：文档化，标准化，综合成标准软件过程
4. 已管理级：制定标准，且被理解与控制
5. 优化级：不断持续改进

- **等级越高，成熟度越高**

## 能力成熟度模型集成（CMMI）

### 阶段式模型

- 关注组织成熟度

### 连续式模型

- 关注每个过程域（6个）的能力
  - cl0（未完成）：
  - cl1（已执行）：输入转为输出
  - cl2（已管理）
  - cl3（已定义）
  - cl4（定量管理）
  - cl5（优化）：持续改进

# 软件过程模型

## 瀑布模型

- **需有经验**，**需求明确**，**变更较小**，以**文档**为驱动，每个阶段结束都需要提供相关文档
- 优点：容易理解，管理成本低
- 缺点：修改成本大

## 增量模型

- 需求明确，把所有需求分成各个增量，强调每个增量均发布一个可操作的产品
- 瀑布模型变体
- 优点：
  1. 瀑布模型所有优点
  2. 第一个可交付版本所需要的**成本和时间很少**
  3. 可以将需求划分为增量（不是很容易）
  4. **适用于商业产品**
- 缺点：
  1. 成本，进度，配置的复杂性可能会失控

## 演化模型

- 迭代的过程模型，适用于对需求缺乏准确认识的情况

### 原型模型

- 先开发一个原型，然后**不断收集需求**
- 适用于**需求不清**，**需求常变**的情况
- 适用于需求**规模不大**，且**不复杂**的系统
- 可有效**捕获系统需求**

### 螺旋模型

- 风险驱动
- 包含为维护周期
- 适用于**大规模，复杂且有高风险**的系统
- 可**识别风险**，**消除风险**
- 缺点：开发成本高，会延迟提交时间，需要专业人员

## 喷泉模型

- **以用户需求为动力，以对象作为驱动**（**适用于面对对象**的开发方法）
- 克服了瀑布模型不支持软件重用，和多项开发活动集成的局限性
- 活动交叉，具有**迭代性**（可以回到之前的阶段）且**无间隙性**
- 优点：
  1. 可提高开发效率，节省开发时间
  2. 开发人员可同步进行
- 缺点：
  1. 需要大量开发人员，不利于项目管理
  2. 需严格管理文档，审核难度大

## 统一过程（UP）模型

- **用例和风险驱动，以架构为中心，迭代并且增量**
- 每个迭代有5**个核心工作流**

## 敏捷方法

### 极限编程（XP）

1. 4大价值观：沟通，简单性，反馈，勇气
2. 5大原则：快速反馈，简单性假设，逐步修改，提倡更改，优质工作
3. 12个最佳实践：计划游戏，**小型发布**，隐喻，简单设计，**测试先行**，重构，结对编程，集体代码所有制，持续集成，每周工作40小时，现场客户，编码标准

### **水晶法：不同项目有不同策略，约定，方法论**

### **并列争求法（CRUM）**

1. **每30天一次迭代（冲刺）**
2. 步骤不包括Refactoring

### 自适应软件开发（ASD）

### **敏捷统一过程（AUP）**

1. **大型任务连续**
2. **小型任务迭代**

# 需求分析

## 软件需求

### 功能需求

- 考虑系统要做什么，在何时做，在何时以及如何修改和升级

### 性能需求

- 考虑软件开发的技术性指标

### 数据需求

- 考虑输入输出数据的格式，接收发送数据的频率，数据准确性和精度，数据流量，数据需保持的时间

# 系统设计

## 概要设计

### **设计软件系统总体结构**

1. **把复杂系统按功能划分成模块**
2. 确定模块间的**调用关系**和**接口**
3. 是概要设计的**关键**一步

### 数据结构及数据库设计

### **编写设计概要文档**

1. 概要设计说明书
2. 数据库设计说明书
3. 用户手册
4. 修订测试计划

### 评审

## 详细设计

- 对每个模块进行详细的**算法设计**
- 对模块内的**数据结构进行设计**
- 对**数据库进行物理设计**，即确定数据库的物理结构
- 系统设计的结果是一系列的**系统设计文件**，这些文件是物理实现一个信息系统的重要基础

# 系统测试

## 系统测试与调试

### **系统测试的意义**

- 为了发现错误而执行程序的过程，成功的测试是发现了至今尚未发现的错误的测试

### 系统测试的目的

- 以最少的人力和时间发现潜在的各种错误和缺陷

### **系统测试的原则**

1. 尽早并不断进行测试，贯穿各个阶段
2. 既要确定输入数据，又要确定预期输出结果
3. 既要有合理，正常的输入，又要有不合理，失效的输入
4. 既要检测该做的事，也要检测不该做的事
5. 可以重新测试或追加测试
6. 系统测试阶段的测试目标来自于**需求分析阶段**

- **测试目标来自于需求分析阶段**

## 传统软件的测试策略

### 单元测试

- 内容：接口，局部数据结构，重要的执行路径，出错处理，边界条件
- 过程：驱动模块，桩模块

### 集成测试

- **自顶向下**：
  1. 增量方法
  2. 抽象到具体
  3. **不需要编写驱动模块，需要编写桩模块**
- **自底向上**：
  1. 从原子模块驾驶进行构造和测试
  2. 具体到抽象
  3. **需要编写驱动模块，不需要编写桩模块**
- **回归测试：重新测试**
- 冒烟测试

### 确认测试

### 系统测试

## 测试方法

### 静态测试

- 人工检测，计算机辅助静态分析

### **动态测试**

- **通过运行程序发现错误**

1. **黑盒测试法：功能测试**
   1. **不关注内部结构及特性**
   2. 技术：
      1. 等价类划分：有效等价类，无效等价类
         1. 只要在条件内就是有效等价类，否则是无效等价类
         2. 若不合理的输入超过一个，则是一个不合适的测试用例
      2. 边界值分析
      3. 错误推测
      4. 因果图
2. **白盒测试法（结构测试）**
   1. **根据内部结构和逻辑来设计测试用例**
   2. 技术：
      1. **逻辑覆盖**
         1. 语句覆盖
            - **每条语句（矩形）至少执行一次**
            - **很弱**的逻辑覆盖
         2. 判定覆盖（分支覆盖）
            - **每个判定表达式的“真”和“假”都至少执行一次**
         3. 条件覆盖
            - 每个判定语句中**每个逻辑条件（判断条件的子条件）的各种可能值（真/假）至少满足一次**
         4. 判定/条件覆盖
            - **判定覆盖∪条件覆盖**
         5. 条件组合覆盖
            - **每个判定中条件的各种可能值的组合都至少出现一次（判断条件的子条件排列组合）**
         6. 路径覆盖
            - **覆盖所有可能路径**
            - **最强**的逻辑覆盖
   3. 原则：
      1. 所有独立路径至少执行一次
      2. 所有逻辑判断中，“真”和“假”都至少执行一次
      3. 每个循环都应在边界条件和一般条件下执行一次
      4. 测试内部数据结构的有效性

### McCabe度量法

- **V(G) = m - n + 2 = 闭合区域 + 1**
  - V(G)：环路个数（**程序/环路复杂度**）
  - m：两边都有节点的有向弧/箭头个数
  - n：节点数
- **代码行数**是度量软件复杂性的一个主要参数

### 白盒测试 + McCabe度量法

- 简单路径：没有重复的结点

### 伪代码+白盒测试 + McCabe度量法

- 先转为程序流程图

# 运行和维护知识

## 系统维护概述

- **不属于系统开发过程**
- 评价指标
  1. 可理解性
  2. 可测试性
  3. 可修改性

### 可维护性

- 衡量软件质量的重要特性
- **文档是软件可维护性的决定因素**
  - 用户文档：描述系统功能与使用方法
  - 系统文档：描述系统设计，实现和测试
- **可维护性**是所有软件的**基本特点**
- **开发阶段保证，每个阶段提高**

### 软件文档

- 编写高质量文档可以提高软件开发质量
- 文档也是软件产品的一部分，没有文档则不是软件
- 其编制有突出的地位和大工作量，对软件产品效益有重要意义
- **软件只好不坏，说文档不好就是错的**

## 系统维护内容及类型

### 硬件维护

### **软件维护**

1. 正确性维护（改正性）
   1. 改正**开发时已发生而测试时未发现的错误**
   2. 随时进行
   3. 工作量：17%-21%
2. 适应性维护
   1. 软件为**适应信息技术和管理需求的变化（数据结构）**而进行的修改
   2. 工作量：18%-25%
3. 完善性维护（改善性）
   1. 为**扩充功能**和**改善性能**而进行的修改
   2. 对完善系统功能非常有必要
   3. 工作量：50%-60%
4. 预防性维护
   1. 为**改进可靠性，可维护性，适应软/硬件环境**
   2. 工作量：4%

### 数据维护

## 可靠性，可用性，可维护性

- 软件的**质量属性**（0~1度量）
- 可靠性
  - 无失效运作的概率
  - **MTTF / (1 + MTTF)**，MTTF为平均无故障时间
  - **不取决于开发方式**
- 可用性
  - 正确运作的概率
  - **MTBF / (1 + MTBF)**，MTBF为平均失效时间间隔
- 可维护性
  - 完成维护活动的概率
  - **1 / (1 + MTTR)**，MTTR为平均修复时间

## 沟通路径

- 无主（相互沟通）：**n \* (n - 1) / 2**
- 有主：**n - 1**

# 软件项目管理

## 软件项目估算

### COCOMO估算模型

- 精确，易使用的成本估算模型
- 详细程度
  1. **基本**COCOMO模型：**静态单变量**模型，对**整个软件系统**进行估算
  2. **中型**COCOMO模型：**静态多变量**模型，把系统**分为系统，部件**
  3. **详细**COCOMO模型：把系统**分为系统，子系统，部件**

### COCOMOII模型

- 层次结构的估算模型
- 阶段性模型
  1. **应用组装型模型（对象点）**
  2. **早期设计阶段模型（功能点）**
  3. **体系结构阶段模型（代码行）**

## 进度管理（进度安排）

### 甘特图（Gantt图）

- 描述何时开始，何时结束，进展情况，**可以表示并行性**
- **无法反映依赖关系，关键点，潜力点**

### 项目计划评审技术图（PERT图）

- 有向图，箭头表示任务，上方可标完成所需时间，下方可标松弛时刻（有括号）
- 结点为事件，流入结点的任务全结束，事件才出现
- **最早时刻**
  - 此时刻之前从该事件触发的任务不可能开始
  - **Max（前一个结点的最早时刻 + 任务耗时）**
  - 从前往后算
- **最迟时刻**
  - 从该事件触发的任务必须在此时刻之前开始，否则无法如期完成
  - **Min（下一结点的最迟时刻 - 任务耗时）**
  - 从后往前算
- **松弛时刻**
  - 不影响工期的余地
  - **只是一个任务的起始结点：起始结点的最迟时刻 - 起始结点的最早时刻**
  - **是多个任务的起始结点：结束结点的最早时刻 - 起始结点的最早时刻 - 任务耗时**
- **关键路径**
  - **松弛时间为0的路径**
  - **路径计算方法：只有一条路径指向，则走这条路，有多条指向，则选择前结点最早时间+任务时间=当前最早时间**
- 开始结点：没有任务指向，最早时刻 = 0
- 结束结点：没有任务指出， 最迟时刻 = 最早时刻
- **可以表示依赖关系，无法反映任务间的并行关系**

### 项目活动图

- 关键路径
- 关键**路径长度：结束结点的最早时刻**

## 软件配置管理

- 主要目标：变更标识，变更控制，版本控制，确保变更正确的实现，变更报告
- 主要内容
  - 版本一：版本管理，配置支持，变更支持，过程支持，团队支持，变化报告，审计支持
  - 版本二：软件配置标识，变更管理，版本控制，系统建立，配置审核，配置状态报告
- 配置数据库：**开发库，受控库，产品库**

## 风险管理

- 两个特性
  - **不确定性：风险可能发生也可能不发生**
  - **损失：**如果风险发生，就会产生恶性后果
- 项目风险
  - 威胁到项目计划
  - 包括**项目复杂度，规模，结构不确定性**
- 技术风险
  - 威胁到软件质量及交付时间
  - 包括**设计，实现，接口，验证和维护**等方面潜在的问题
- 商业风险
  - 威胁到软件生存能力

### 风险识别

系统化的指出对项目计划（估算，进度，资源分配）的威胁

方法：建立风险条目检查表

### 风险预测（风险估计）

- **不能完全避免预测到的风险的发生**

- 从两个方面评估风险

  1. 风险发生的**可能性或概率**
  2. 风险发生的**后果**

- 风险预测活动

  1. 建立尺度或标准
  2. 描述风险产生的后果
  3. 估算风险对项目的影响
  4. 标注风险精确度

  - 预测技术：风险表

- 评估风险影响（优先级）

- 影响因素：本质，范围，时间

- **风险显露度（暴露）（RE）**

  **RE = P \* C**

  - P：风险发生**概率**
  - C：风险发生时的项目**成本**

### 风险评估

- **（r，l，x）**
  - r：风险
  - l：**风险概率**
  - x：**风险后果**
- 对风险评估很有用的技术：**风险参照水准**
- 成本超支
- 进度延期
- 性能降低

### 风险控制

- **目的：辅助项目组建立处理风险的策略**
- **风险避免：最好办法是主动避免风险**

### 风险监控

- RMMM计划：将所有风险分析工作文档化，并由管理者使用

# 软件质量

## 软件质量特性

### ISO/IEC 9126 软件质量模型

| **质量特性** | **质量子特性** | **度量指标** |
| ------------ | -------------- | ------------ |
| 功能性       | 适应性         |              |
|              | 准确性         |              |
|              | 互用性         |              |
|              |                |              |
|              |                |              |
|              |                |              |

### Mc Call 软件质量模型

- 产品修正：可维护性，灵活性，可测试性
- 产品转移：可以执行，复用性，互用性
- 产品运行：正确性，可靠性，易用性，效率，完整性

## 软件评审

- 质量 = 用户满意程度
- 必要条件
  1. **设计质量**的评审内容
     1. 评价规格说明是否符合用户要求
     2. 评审可靠性
     3. 评审保密性
     4. 评审操作特性实施情况
     5. 评审性能实现情况
     6. 评审可测试性
     7. 评审复用性
  2. **程序质量**的评审内容（与**开发**技术直接相关）
     1. 功能结构
     2. 功能的通用性
     3. 模块的层次
     4. **模块结构**
        1. **控制流**结构
        2. **数据流**结构
        3. 模块结构与功能结构之间的**对应关系**
     5. 处理过程的结构

## 软件容错技术

- **容错的一般方法：冗余**
- 结构冗余
  1. 静态冗余
  2. 动态冗余
  3. 混合冗余
- 信息冗余
- 时间冗余
- 冗余附加技术

# 软件工具与软件开发环境

## 软件工具

### 软件开发工具

- 需求分析工具
- 设计工具
- 编码与排错工具
- 测试工具

### 软件维护工具

- 文档分析工具
- 开发信息库工具
- 逆向工程工具
- 再工程工具

# 杂

1. **Jackson**方法不属于面向对象的方法
2. 软件工程的基本要素包括**方法，工具，过程**
3. 编译器不属于仓库风格
4. 