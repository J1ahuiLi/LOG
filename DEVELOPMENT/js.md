# JavaScript 面试题及标准答案（100 道）

## 一、JS 基础语法题（1-20 题）

| 题号 |                      问题                       |                           标准答案                           |
| :--: | :---------------------------------------------: | :----------------------------------------------------------: |
|  1   | JS 的数据类型有哪些？基本类型和引用类型的区别？ | 数据类型：1. 基本类型：String、Number、Boolean、Null、Undefined、Symbol（ES6）、BigInt（ES10）；2. 引用类型：Object（包含 Array、Function、Date、RegExp 等）；区别：1. 基本类型存储在栈内存，值不可变；2. 引用类型存储在堆内存，栈内存存地址，值可变；3. 赋值时：基本类型复制值，引用类型复制地址（浅拷贝）。 |
|  2   |   `typeof` 操作符返回值有哪些？有什么局限性？   | 返回值：string、number、boolean、undefined、symbol、bigint、function、object；局限性：1. `typeof null` 返回 `object`（历史 bug）；2. 数组 / 日期 / 正则等引用类型均返回 `object`。 |
|  3   |          如何判断一个变量是否为数组？           | 3 种常用方式：1. `Array.isArray(arr)`（最推荐，ES5+）；2. `arr instanceof Array`（需注意原型链污染）；3. `Object.prototype.toString.call(arr) === '[object Array]'`（通用类型判断）。 |
|  4   |         `null` 和 `undefined` 的区别？          | 1. 含义：`undefined` 表示变量声明未赋值 / 属性不存在；`null` 表示 “空值”，主动赋值表示无对象；2. 类型：`typeof undefined` → `undefined`；`typeof null` → `object`；3. 转换：`Number(undefined)` → `NaN`；`Number(null)` → `0`。 |
|  5   |  什么是变量提升？函数提升和变量提升的优先级？   | 变量提升：JS 引擎在执行代码前，将变量声明提升到当前作用域顶部（仅声明，赋值保留在原地）；函数提升：函数声明整体提升（可先调用后声明）；优先级：函数提升 > 变量提升（同名时函数声明覆盖变量声明）。 |
|  6   |         `let`/`const` 和 `var` 的区别？         | 1. 作用域：`var` 是函数作用域，`let/const` 是块级作用域；2. 变量提升：`var` 有提升且初始化`undefined`，`let/const` 有 “暂时性死区”（TDZ），未声明前访问报错；3. 重复声明：`var` 允许，`let/const` 禁止；4. 全局变量：`var` 声明的全局变量挂载到`window`，`let/const` 不挂载；5. `const`：声明常量，必须初始化，指向的地址不可变（值可变，如对象属性）。 |
|  7   |            什么是暂时性死区（TDZ）？            | 指`let/const`声明的变量，在声明语句执行前的区域，访问该变量会报错；示例：`console.log(a); let a = 1;` → 报错（a 在 TDZ 中）。 |
|  8   |       JS 的作用域有哪些？作用域链是什么？       | 作用域：1. 全局作用域：代码最外层，变量全局可访问；2. 函数作用域：函数内部，变量仅函数内可访问；3. 块级作用域：`{}`内（let/const）；作用域链：当前作用域可访问上级作用域的变量，形成链式结构；查找变量时从当前作用域向上找，直到全局作用域。 |
|  9   |         什么是闭包？闭包的作用和缺点？          | 定义：函数嵌套时，内层函数访问外层函数的变量 / 参数，形成闭包（外层函数执行后，变量仍被内层函数引用）；作用：1. 私有化变量（避免全局污染）；2. 保存变量状态（如计数器）；缺点：变量长期驻留内存，可能导致内存泄漏（需手动释放）。 |
|  10  |    什么是立即执行函数（IIFE）？作用是什么？     | 写法：`(function(){})()` 或 `(function(){}())`；作用：1. 创建独立作用域，避免变量污染全局；2. 早期替代块级作用域（ES6 前）。 |
|  11  |            运算符`==`和`===`的区别？            | 1. `==`：松散相等，先隐式类型转换再比较值；2. `===`：严格相等，不转换类型，值和类型都相等才返回 true；示例：`0 == false` → true；`0 === false` → false；`null == undefined` → true；`null === undefined` → false。 |
|  12  |           JS 隐式类型转换的常见场景？           | 1. 算术运算：`1 + '2'` → `'12'`（数字转字符串）；`'1' - 0` → 1（字符串转数字）；2. 逻辑判断：`if ('')` → false（空字符串转 false）；`if ([])` → true（空数组转 true）；3. 比较运算：`1 == '1'` → true；核心规则：转数字 / 转字符串 / 转布尔（遵循 “真值 / 假值” 规则）。 |
|  13  |               JS 中的假值有哪些？               | 共 6 个：`undefined`、`null`、`0`、`''`（空字符串）、`NaN`、`false`；其余均为真值（如`[]`、`{}`、`'0'`）。 |
|  14  |            `this` 指向的规则有哪些？            | 核心规则（优先级从高到低）：1. 显式绑定：`call/apply/bind` 绑定的对象；2. 隐式绑定：调用者对象（如`obj.fn()`中 this 指向 obj）；3. new 绑定：构造函数中 this 指向实例对象；4. 默认绑定：全局作用域中 this 指向 window（严格模式下为 undefined）；补充：箭头函数无 this，继承外层作用域的 this。 |
|  15  |        `call`、`apply`、`bind` 的区别？         | 相同点：改变函数 this 指向；区别：1. `call/apply` 立即执行函数，`bind` 返回新函数（需调用执行）；2. 参数传递：`call` 传多个参数（逗号分隔），`apply` 传数组，`bind` 传多个参数（逗号分隔，支持柯里化）；示例：`fn.call(obj, 1, 2)`；`fn.apply(obj, [1, 2])`；`let newFn = fn.bind(obj, 1, 2)`。 |
|  16  |           箭头函数和普通函数的区别？            | 1. `this`：箭头函数无 this，继承外层作用域的 this；普通函数 this 指向调用者；2. 构造函数：箭头函数不能作为构造函数（无 prototype，new 调用报错）；3. arguments：箭头函数无 arguments 对象（可用剩余参数`...args`替代）；4. 简写：支持省略括号（单参数）、省略大括号（单语句）、自动返回（单语句）。 |
|  17  |              什么是原型和原型链？               | 原型：1. 每个函数有`prototype`（原型对象），每个对象有`__proto__`（隐式原型）；2. 构造函数的`prototype` === 实例的`__proto__`；原型链：对象访问属性时，先找自身属性，找不到则通过`__proto__`找原型对象的属性，直到`Object.prototype`（顶端），形成的链式结构。 |
|  18  |      如何实现继承？常用的继承方式有哪些？       | 常用方式：1. 原型链继承：`Child.prototype = new Parent()`（缺点：父类引用属性共享）；2. 构造函数继承：`Parent.call(this, args)`（缺点：不能继承原型方法）；3. 组合继承：原型链 + 构造函数（缺点：父类构造函数执行两次）；4. 寄生组合继承（最优）：`Child.prototype = Object.create(Parent.prototype)` + `Child.prototype.constructor = Child`；5. ES6 类继承：`class Child extends Parent {}`（语法糖，底层仍是原型链）。 |
|  19  |     `Object.create(null)` 和 `{}` 的区别？      | 1. `{}` 的`__proto__`指向`Object.prototype`，继承 Object 的方法（如 toString、hasOwnProperty）；2. `Object.create(null)` 创建的对象无`__proto__`，无任何继承方法，更纯净（适合做字典）。 |
|  20  |        什么是浅拷贝和深拷贝？如何实现？         | 浅拷贝：仅复制对象地址，嵌套对象共享（修改拷贝后的嵌套对象会影响原对象）；实现：`Object.assign()`、扩展运算符`{...obj}`、数组`slice()`/`concat()`；深拷贝：复制所有层级的属性，嵌套对象独立（修改互不影响）；实现：1. `JSON.parse(JSON.stringify(obj))`（缺点：不支持函数、RegExp、undefined、循环引用）；2. 递归实现深拷贝函数（处理所有类型）。 |

## 二、JS 数组 / 字符串 / 对象题（21-40 题）

| 题号 |                             问题                             |                           标准答案                           |                   |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: | :---------------: |
|  21  |    数组的常用方法有哪些？分类说明（改变原数组 / 不改变）     | 改变原数组：push、pop、shift、unshift、splice、sort、reverse；不改变原数组：concat、slice、join、map、filter、forEach、reduce、find、findIndex、every、some；示例：- push：尾部添加元素，返回新长度；- splice (start, deleteCount, ...add)：删除 / 添加元素，返回删除的数组；- map：遍历数组，返回新数组（每个元素为回调返回值）。 |                   |
|  22  |                 `forEach` 和 `map` 的区别？                  | 1. 返回值：`forEach` 返回 undefined，`map` 返回新数组；2. 中断遍历：两者都不能用 break 中断（forEach 抛异常也不行）；3. 用途：`forEach` 仅遍历执行操作，`map` 用于转换数组（如数据格式化）。 |                   |
|  23  |                 `reduce` 的用法？举例说明。                  | 语法：`arr.reduce((prev, curr, index, arr) => {}, initialValue)`；作用：遍历数组，累计计算返回最终值；示例：1. 求和：`[1,2,3].reduce((sum, n) => sum + n, 0)` → 6；2. 数组去重：`arr.reduce((res, n) => res.includes(n) ? res : [...res, n], [])`；3. 扁平化数组：`[[1,2],[3,4]].reduce((res, arr) => [...res, ...arr], [])`。 |                   |
|  24  |                     数组去重的常用方法？                     | 1. ES6 Set：`[...new Set(arr)]`（简洁，推荐）；2. reduce：如上题示例；3. 遍历 + includes：`let res = []; arr.forEach(n => !res.includes(n) && res.push(n))`；4. 对象键值对：利用对象属性唯一（处理复杂类型）。 |                   |
|  25  |                     如何实现数组扁平化？                     | 1. ES6 flat：`arr.flat(Infinity)`（Infinity 表示无限层级）；2. 递归：`function flat(arr) { let res = []; arr.forEach(item => Array.isArray(item) ? res.push(...flat(item)) : res.push(item)); return res; }`；3. 正则：`JSON.parse('[' + JSON.stringify(arr).replace(/\[|\]/g, '') + ']')`（仅数字数组）。 |                   |
|  26  |                   字符串的常用方法有哪些？                   | 1. 查找：indexOf、includes、startsWith、endsWith、charAt；2. 截取：slice、substring、substr；3. 替换：replace、replaceAll（ES2021）；4. 转换：toLowerCase、toUpperCase、split；5. 去除空格：trim、trimStart、trimEnd；示例：`'abc'.replace('a', 'A')` → 'Abc'；`'a b c'.split(' ')` → ['a','b','c']。 |                   |
|  27  |                 `slice` 和 `splice` 的区别？                 | 1. 作用对象：`slice` 可用于数组 / 字符串，`splice` 仅用于数组；2. 原数组：`slice` 不改变原数组，`splice` 改变；3. 参数：`slice(start, end)`（结束位置不包含），`splice(start, deleteCount, ...add)`；4. 返回值：`slice` 返回截取的新数组 / 字符串，`splice` 返回删除的数组。 |                   |
|  28  |                 如何判断对象是否有某个属性？                 | 1. `in` 运算符：`'name' in obj`（检查自身 + 原型属性）；2. `hasOwnProperty`：`obj.hasOwnProperty('name')`（仅检查自身属性，推荐）；3. `Object.prototype.hasOwnProperty.call(obj, 'name')`（避免 obj 重写 hasOwnProperty）。 |                   |
|  29  |                     遍历对象的常用方法？                     | 1. `for...in`：遍历对象自身 + 原型的可枚举属性（需配合 hasOwnProperty 过滤）；2. `Object.keys(obj)`：返回自身可枚举属性名数组；3. `Object.values(obj)`：返回自身可枚举属性值数组；4. `Object.entries(obj)`：返回自身可枚举属性 [key, value] 数组；5. `Object.getOwnPropertyNames(obj)`：返回自身所有属性（含不可枚举）。 |                   |
|  30  |                    什么是对象的可枚举性？                    | 指对象属性的`enumerable`特性，可枚举的属性会被`for...in`、`Object.keys`等遍历到；默认：直接定义的属性可枚举，原型链的属性（如 toString）不可枚举；修改：`Object.defineProperty(obj, 'name', { enumerable: false })`。 |                   |
|  31  |                  如何实现对象的属性私有化？                  | 1. 闭包：将属性放在外层函数，内层函数暴露方法访问；2. ES6 Symbol：用唯一 Symbol 作为属性名（无法遍历，但可通过 Reflect.ownKeys 获取）；3. ES6 private 字段：`class User { #name = '张三'; get name() { return this.#name; } }`（真正私有，外部无法访问）。 |                   |
|  32  |                `JSON.stringify` 的注意事项？                 | 1. 忽略函数、undefined、Symbol 属性；2. 循环引用会报错；3. 日期对象转为 ISO 字符串；4. 可传第二个参数（replacer）过滤属性，第三个参数（space）格式化；示例：`JSON.stringify({a: 1, b: () => {}, c: undefined}, ['a'])` → '{"a":1}'。 |                   |
|  33  |                如何将类数组转换为真正的数组？                | 类数组：有 length 属性，索引访问（如 arguments、DOM 集合）；实现：1. ES6 Array.from：`Array.from(arguments)`；2. 扩展运算符：`[...arguments]`；3. slice：`Array.prototype.slice.call(arguments)`。 |                   |
|  34  |         数组的`sort`方法原理？如何实现数字升序排序？         | 原理：默认按字符串 Unicode 码点排序（如`[10,2].sort()` → [10,2]）；数字升序：`arr.sort((a, b) => a - b)`；数字降序：`arr.sort((a, b) => b - a)`。 |                   |
|  35  | `String.prototype.trim()` 的作用？如何实现兼容低版本浏览器？ | 作用：去除字符串首尾空格（含换行、制表符）；兼容实现：`String.prototype.trim = function () { return this.replace (/^\s+ | \s+$/g, ''); }`。 |
|  36  |                 如何判断一个变量是否为函数？                 | 1. `typeof fn === 'function'`（推荐）；2. `Object.prototype.toString.call(fn) === '[object Function]'`。 |                   |
|  37  |                 数组的`find`和`filter`区别？                 | 1. 返回值：`find` 返回第一个满足条件的元素（无则 undefined），`filter` 返回所有满足条件的元素数组；2. 终止遍历：`find` 找到后立即终止，`filter` 遍历全部。 |                   |
|  38  |                  `Object.freeze()` 的作用？                  | 冻结对象，使其不可修改：1. 不能添加 / 删除属性；2. 不能修改属性值（浅冻结，嵌套对象仍可修改）；深冻结：需递归冻结所有层级属性。 |                   |
|  39  |                     如何实现字符串反转？                     | 1. 拆分 + 反转 + 拼接：`'abc'.split('').reverse().join('')` → 'cba'；2. 遍历：`let res = ''; for (let i = str.length - 1; i >= 0; i--) res += str[i];`。 |                   |
|  40  |            什么是 NaN？如何判断一个值是否为 NaN？            | NaN：Not a Number，非数字（如`1 / 'a'`）；特点：`NaN !== NaN`（唯一不等于自身的值）；判断：1. `Number.isNaN(val)`（ES6，仅判断是否为 NaN）；2. `Object.is(val, NaN)`；注意：`isNaN(val)` 会先隐式转换，如`isNaN('a')` → true（不推荐）。 |                   |

## 三、JS 异步编程题（41-60 题）

| 题号 |                             问题                             |                           标准答案                           |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  41  |      JS 为什么是单线程？什么是事件循环（Event Loop）？       | 单线程原因：避免 DOM 渲染冲突（如同时修改同一个 DOM）；事件循环：JS 处理异步任务的机制，步骤：1. 同步任务进入主线程执行；2. 异步任务（如定时器、Ajax）进入 “任务队列”；3. 主线程执行完同步任务，读取任务队列，将异步任务推入主线程执行；4. 重复以上步骤（循环）。 |
|  42  |             宏任务和微任务的区别？分别包含哪些？             | 分类：1. 宏任务（Macrotask）：script 整体、setTimeout、setInterval、setImmediate（Node）、I/O、UI 渲染；2. 微任务（Microtask）：Promise.then/catch/finally、async/await、process.nextTick（Node）、MutationObserver；执行顺序：1. 执行完一个宏任务，清空所有微任务；2. 再执行下一个宏任务，以此循环。 |
|  43  |             手写 Promise 的核心逻辑（简易版）。              | `js class MyPromise { constructor(executor) { this.status = 'pending'; // pending/fulfilled/rejected this.value = undefined; this.reason = undefined; this.onResolvedCallbacks = []; // 成功回调队列 this.onRejectedCallbacks = []; // 失败回调队列 const resolve = (value) => { if (this.status === 'pending') { this.status = 'fulfilled'; this.value = value; this.onResolvedCallbacks.forEach(fn => fn()); } }; const reject = (reason) => { if (this.status === 'pending') { this.status = 'rejected'; this.reason = reason; this.onRejectedCallbacks.forEach(fn => fn()); } }; try { executor(resolve, reject); } catch (e) { reject(e); } } then(onFulfilled, onRejected) { onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v; onRejected = typeof onRejected === 'function' ? onRejected : e => { throw e; }; const promise2 = new MyPromise((resolve, reject) => { if (this.status === 'fulfilled') { setTimeout(() => { try { const x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); } if (this.status === 'rejected') { setTimeout(() => { try { const x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); } if (this.status === 'pending') { this.onResolvedCallbacks.push(() => { setTimeout(() => { try { const x = onFulfilled(this.value); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); }); this.onRejectedCallbacks.push(() => { setTimeout(() => { try { const x = onRejected(this.reason); resolvePromise(promise2, x, resolve, reject); } catch (e) { reject(e); } }, 0); }); } }); return promise2; } // 简化版resolvePromise function resolvePromise(promise2, x, resolve, reject) { if (x === promise2) { return reject(new TypeError('循环引用')); } if (x instanceof MyPromise) { x.then(resolve, reject); } else { resolve(x); } } } ` |
|  44  |            Promise 的常用方法有哪些？作用是什么？            | 1. `Promise.resolve(value)`：返回成功状态的 Promise；2. `Promise.reject(reason)`：返回失败状态的 Promise；3. `Promise.all(arr)`：所有 Promise 成功才成功，返回结果数组；有一个失败则立即失败；4. `Promise.race(arr)`：第一个完成的 Promise 决定结果（无论成功 / 失败）；5. `Promise.allSettled(arr)`：所有 Promise 完成后返回，每个结果包含 status 和 value/reason；6. `Promise.any(arr)`：第一个成功的 Promise 决定结果，全部失败则抛 AggregateError。 |
|  45  |          `async/await` 的原理？和 Promise 的关系？           | 原理：`async/await` 是 Promise 的语法糖，底层基于生成器（Generator）和自动执行器；关系：1. `async` 函数返回一个 Promise；2. `await` 后面跟 Promise（非 Promise 则转为 Promise），暂停函数执行，直到 Promise 完成；3. `await` 相当于 Promise.then 的语法糖，错误可通过 try/catch 捕获。 |
|  46  |                      如何解决回调地狱？                      | 1. Promise：将嵌套回调转为链式调用（then/catch）；2. async/await：将异步代码转为 “同步” 写法（最优雅）；3. 模块化：拆分回调函数为独立函数，减少嵌套。 |
|  47  |            setTimeout 的延迟时间为什么可能不准？             | 1. JS 单线程，setTimeout 的回调进入宏任务队列，需等主线程和微任务执行完才会执行；2. 延迟时间最小值为 4ms（浏览器限制）；3. 后台标签页的定时器延迟会增大（如 1000ms）。 |
|  48  |              如何实现 sleep 函数（延迟执行）？               | `js // 基于Promise function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); } // 使用： await sleep(1000); console.log('延迟1秒执行'); ` |
|  49  |                 什么是防抖和节流？如何实现？                 | 防抖（debounce）：定义：触发事件后延迟 n 秒执行，若 n 秒内再次触发，重置延迟时间；场景：搜索框输入联想、窗口 resize；实现：`js function debounce(fn, delay) { let timer = null; return (...args) => { clearTimeout(timer); timer = setTimeout(() => fn.apply(this, args), delay); }; } `节流（throttle）：定义：触发事件后，n 秒内仅执行一次；场景：滚动加载、按钮点击防重复；实现（时间戳版）：`js function throttle(fn, delay) { let lastTime = 0; return (...args) => { const now = Date.now(); if (now - lastTime > delay) { fn.apply(this, args); lastTime = now; } }; } ` |
|  50  |           Ajax 的核心步骤？Fetch 和 Ajax 的区别？            | Ajax 核心步骤（原生）：1. 创建 XMLHttpRequest 对象：`const xhr = new XMLHttpRequest();`；2. 配置请求：`xhr.open('GET', 'url', true);`（true 异步）；3. 监听状态：`xhr.onreadystatechange = () => { if (xhr.readyState === 4 && xhr.status === 200) { console.log(xhr.responseText); } }`；4. 发送请求：`xhr.send();`；Fetch vs Ajax：1. Fetch 基于 Promise，无需回调；2. Fetch 默认不携带 Cookie（需配置 credentials: 'include'）；3. Fetch 错误状态（如 404）不会 reject（需手动判断 status）；4. Fetch 可中断（AbortController）。 |
|  51  |                   如何取消 Promise 请求？                    | 1. 基于 AbortController（Fetch/Ajax）：`js const controller = new AbortController(); const signal = controller.signal; fetch('url', { signal }).catch(err => { if (err.name === 'AbortError') console.log('请求取消'); }); // 取消请求 controller.abort(); `2. 封装 Promise 时添加取消逻辑（如标记变量）。 |
|  52  |                Promise 的异常捕获方式有哪些？                | 1. `then`的第二个参数：`promise.then(res => {}, err => {})`；2. `catch`方法：`promise.catch(err => {})`（推荐，可捕获 then 中的错误）；3. `try/catch`（async/await）：`js async function fn() { try { await promise; } catch (err) { console.log(err); } } `；4. 全局捕获：`window.addEventListener('unhandledrejection', (e) => { e.preventDefault(); console.log(e.reason); })`。 |
|  53  |                   什么是 Promise 的穿透？                    | 指 Promise 的 then/catch 不传回调函数时，会将结果透传给下一个 then/catch；示例：`Promise.resolve(1).then().then(res => console.log(res))` → 1；`Promise.reject(2).catch().catch(err => console.log(err))` → 2。 |
|  54  | 执行顺序题：`console.log(1); setTimeout(() => console.log(2), 0); Promise.resolve().then(() => console.log(3)); console.log(4);` 输出结果？ | 输出：1 → 4 → 3 → 2；解析：1. 执行同步任务：console.log (1)、console.log (4)；2. 清空微任务：Promise.then → console.log (3)；3. 执行宏任务：setTimeout → console.log (2)。 |
|  55  |            什么是 Generator 函数？如何自动执行？             | 定义：`function* gen() { yield 1; yield 2; return 3; }`，调用返回迭代器，需 next () 执行；自动执行：1. 递归调用 next ()；2. 使用 co 库（async/await 的底层实现）；示例：`js function co(gen) { const iter = gen(); function next(res) { const { value, done } = iter.next(res); if (done) return value; if (value instanceof Promise) { value.then(next).catch(err => iter.throw(err)); } else { next(value); } } next(); } ` |
|  56  |           什么是事件委托（事件代理）？作用是什么？           | 定义：将子元素的事件绑定到父元素，利用事件冒泡触发；场景：动态生成的元素绑定事件；作用：1. 减少事件绑定数量，提升性能；2. 支持动态元素的事件绑定；示例：`js document.querySelector('ul').addEventListener('click', (e) => { if (e.target.tagName === 'LI') { console.log(e.target.textContent); } }); ` |
|  57  |             事件冒泡和事件捕获的区别？如何阻止？             | 事件流：捕获阶段 → 目标阶段 → 冒泡阶段；事件捕获：从最外层元素到目标元素；事件冒泡：从目标元素到最外层元素；阻止冒泡：`e.stopPropagation()`；阻止默认行为：`e.preventDefault()`（如阻止 a 标签跳转）；绑定事件时指定捕获：`addEventListener('click', fn, true)`（第三个参数 true）。 |
|  58  |                    什么是跨域？如何解决？                    | 跨域：浏览器同源策略限制，协议、域名、端口任一不同即为跨域；解决方式：1. CORS（后端）：服务器设置响应头`Access-Control-Allow-Origin: *`；2. JSONP：利用 script 标签无跨域限制，仅支持 GET；3. 代理（前端）：webpack devServer 代理、Nginx 反向代理；4. postMessage：跨窗口通信；5. WebSocket：无跨域限制。 |
|  59  |           async 函数中 await 后面的代码执行顺序？            | `await` 后面的代码属于微任务，会在当前宏任务的微任务队列中执行；示例：`js async function fn() { console.log(1); await console.log(2); console.log(3); // 微任务 } console.log(4); fn(); console.log(5); `输出：4 → 1 → 2 → 5 → 3。 |
|  60  |              如何实现 Promise.all 的重试逻辑？               | `js async function promiseAllWithRetry(promises, retryCount = 3) { let attempts = 0; while (attempts < retryCount) { try { return await Promise.all(promises.map(p => p())); // 传入返回Promise的函数 } catch (err) { attempts++; if (attempts === retryCount) throw err; console.log(`重试第${attempts}次`); await sleep(1000); // 延迟1秒重试 } } } ` |

## 四、JS DOM/BOM 题（61-80 题）

| 题号 |                            问题                             |                           标准答案                           |      |                                                              |
| :--: | :---------------------------------------------------------: | :----------------------------------------------------------: | :--: | :----------------------------------------------------------: |
|  61  |                  获取 DOM 元素的常用方法？                  | 1. `document.getElementById('id')`（返回单个元素）；2. `document.getElementsByClassName('class')`（返回 HTMLCollection，动态）；3. `document.getElementsByTagName('tag')`（返回 HTMLCollection，动态）；4. `document.querySelector('selector')`（返回第一个匹配元素，静态）；5. `document.querySelectorAll('selector')`（返回 NodeList，静态）。 |      |                                                              |
|  62  |  动态集合（HTMLCollection）和静态集合（NodeList）的区别？   | 1. 动态集合：getElementsByClassName/TagName 返回，DOM 变化会自动更新；2. 静态集合：querySelectorAll 返回，DOM 变化不会更新（快照）；示例：`const divs = document.getElementsByTagName('div'); document.body.appendChild(document.createElement('div')); console.log(divs.length);` → 长度 + 1。 |      |                                                              |
|  63  |                 操作 DOM 节点的方法有哪些？                 | 1. 创建：`document.createElement('div')`、`document.createTextNode('文本')`；2. 添加：`parent.appendChild(child)`、`parent.insertBefore(newNode, refNode)`；3. 删除：`parent.removeChild(child)`、`node.remove()`（ES6）；4. 替换：`parent.replaceChild(newNode, oldNode)`；5. 克隆：`node.cloneNode(true)`（true 深克隆，false 浅克隆）。 |      |                                                              |
|  64  |               如何修改 DOM 元素的样式和类名？               | 样式：1. 行内样式：`element.style.color = 'red'`（驼峰命名，如 backgroundColor）；2. 计算样式：`getComputedStyle(element).color`（只读）；类名：1. `element.className = 'active'`（覆盖）；2. `element.classList.add('active')`（添加）、`remove`（删除）、`toggle`（切换）、`contains`（判断）。 |      |                                                              |
|  65  |                事件绑定的方式有哪些？区别？                 | 1. 行内绑定：`<div onclick="fn()"></div>`（耦合高，不推荐）；2. 属性绑定：`element.onclick = fn`（只能绑定一个，覆盖）；3. 事件监听：`element.addEventListener('click', fn)`（可绑定多个，支持捕获 / 冒泡，推荐）。 |      |                                                              |
|  66  |         什么是事件对象（Event）？常用属性 / 方法？          | 事件触发时传入回调的参数，包含事件信息；常用属性：1. `e.target`：触发事件的目标元素；2. `e.currentTarget`：绑定事件的元素；3. `e.type`：事件类型；4. `e.preventDefault()`：阻止默认行为；5. `e.stopPropagation()`：阻止冒泡 / 捕获；6. `e.stopImmediatePropagation()`：阻止后续所有事件监听。 |      |                                                              |
|  67  |                BOM 的常用对象有哪些？作用？                 | 1. window：全局对象，包含所有 BOM/DOM 对象；2. location：URL 信息，`location.href`（跳转）、`location.reload()`（刷新）、`location.search`（查询参数）；3. history：历史记录，`history.back()`、`history.forward()`、`history.pushState()`；4. navigator：浏览器信息，`navigator.userAgent`（判断浏览器）、`navigator.geolocation`（定位）；5. screen：屏幕信息，`screen.width`、`screen.height`。 |      |                                                              |
|  68  |                     如何实现页面跳转？                      | 1. `location.href = 'url'`（普通跳转）；2. `location.replace('url')`（无历史记录）；3. `window.open('url')`（新窗口）；4. `history.pushState({}, '', 'url')`（无刷新跳转）。 |      |                                                              |
|  69  |        什么是 DOMContentLoaded 和 load 事件？区别？         | 1. DOMContentLoaded：DOM 解析完成触发（无需等待图片 / 样式加载）；2. load：页面所有资源（图片、样式、JS）加载完成触发；执行顺序：DOMContentLoaded → load。 |      |                                                              |
|  70  |                 如何检测图片是否加载完成？                  | 1. `img.onload = () => console.log('加载完成')`；2. `img.onerror = () => console.log('加载失败')`；3. 批量图片加载：Promise.all + img.onload。 |      |                                                              |
|  71  |                  什么是 Cookie？如何操作？                  | 定义：存储在客户端的小型文本数据（4KB），随请求发送到服务器；操作：1. 设置：`document.cookie = 'name=张三; expires=' + new Date('2026-01-01').toUTCString() + '; path=/'`；2. 获取：`document.cookie`（返回所有 Cookie 字符串，需解析）；3. 删除：设置 expires 为过去时间。 |      |                                                              |
|  72  |                    如何实现图片懒加载？                     | 1. 原生 loading 属性：`<img src="占位图.jpg" data-src="真实图.jpg" loading="lazy">`；2. 手动实现：`js const imgs = document.querySelectorAll('img[data-src]'); const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { const img = entry.target; img.src = img.dataset.src; img.removeAttribute('data-src'); observer.unobserve(img); } }); }); imgs.forEach(img => observer.observe(img)); ` |      |                                                              |
|  73  |      什么是回流（Reflow）和重绘（Repaint）？如何优化？      | 回流：DOM 布局变化（如尺寸、位置），浏览器重新计算布局（性能消耗大）；重绘：样式变化（如颜色），不影响布局，重新绘制元素；优化：1. 批量修改 DOM（如文档碎片 DocumentFragment）；2. 隐藏元素后修改（display: none）；3. 使用 CSS transform（不会触发回流）；4. 避免频繁读取 offsetWidth/offsetHeight（缓存值）。 |      |                                                              |
|  74  |                  如何获取 URL 的查询参数？                  | `js function getQueryParams() { const params = {}; const search = location.search.slice(1); // 去掉? search.split('&').forEach(item => { const [key, value] = item.split('='); params[key] = decodeURIComponent(value); }); return params; } // 使用：getQueryParams().id ` |      |                                                              |
|  75  |                  什么是 JSONP？如何实现？                   | 定义：利用 script 标签无跨域限制，实现跨域请求；实现：1. 前端：`js function jsonp(url, callbackName) { return new Promise(resolve => { const script = document.createElement('script'); script.src = `${url}?callback=${callbackName}`; window[callbackName] = (data) => { resolve(data); document.body.removeChild(script); delete window[callbackName]; }; document.body.appendChild(script); }); } // 使用：jsonp('http://xxx.com/api', 'callbackFn'); `2. 后端：返回`callbackFn({data: 'xxx'})`。 |      |                                                              |
|  76  |                     如何实现拖拽功能？                      | 核心步骤：1. 给元素设置`draggable="true"`；2. 监听`dragstart`（记录拖拽数据）；3. 监听`dragover`（阻止默认行为，否则 drop 不触发）；4. 监听`drop`（处理拖拽完成逻辑）；示例：`js const dragEl = document.getElementById('drag'); const dropEl = document.getElementById('drop'); dragEl.ondragstart = (e) => e.dataTransfer.setData('text', dragEl.id); dropEl.ondragover = (e) => e.preventDefault(); dropEl.ondrop = (e) => { const id = e.dataTransfer.getData('text'); dropEl.appendChild(document.getElementById(id)); }; ` |      |                                                              |
|  77  | 什么是 Web Storage？localStorage 和 sessionStorage 的区别？ | Web Storage：HTML5 本地存储，包括 localStorage 和 sessionStorage；区别：1. 生命周期：localStorage 永久存储（手动删除），sessionStorage 会话结束（关闭标签）删除；2. 共享：localStorage 同源页面共享，sessionStorage 仅同标签页共享；3. 存储大小：约 5MB（远大于 Cookie）。 |      |                                                              |
|  78  |              如何实现页面刷新后保留表单数据？               | 利用 localStorage：```js // 监听输入 const inputs = document.querySelectorAll ('input'); inputs.forEach (input => { // 页面加载时恢复 input.value = localStorage.getItem (`form_${input.name}`) |      | ''; input.oninput = () => { localStorage.setItem(`form_${input.name}`, input.value); }; }); ``` |
|  79  |                什么是 CSRF 攻击？如何防范？                 | 定义：跨站请求伪造，利用用户登录态发起恶意请求；防范：1. 验证 Referer/Origin 请求头；2. 使用 CSRF Token（请求时携带随机 Token）；3. 同源检测；4. 设置 Cookie 的 SameSite 属性（Strict/Lax）。 |      |                                                              |
|  80  |               如何判断页面是否在前台 / 后台？               | `js // 监听visibilitychange事件 document.addEventListener('visibilitychange', () => { if (document.hidden) { console.log('页面后台'); } else { console.log('页面前台'); } }); ` |      |                                                              |

## 五、JS 进阶 / 实战题（81-100 题）

|   题号    |                     问题                      |                           标准答案                           |      |          |            |
| :-------: | :-------------------------------------------: | :----------------------------------------------------------: | :--: | :------: | :--------: |
|    81     | 什么是模块化？CommonJS 和 ES6 Module 的区别？ | 模块化：将代码拆分为独立文件，按需导入导出，避免全局污染；区别： | 特性 | CommonJS | ES6 Module |
|  ------   |                  ----------                   |                         ------------                         |      |          |            |
| 加载方式  |              运行时加载（动态）               |                      编译时加载（静态）                      |      |          |            |
|   导出    |            module.exports/exports             |                    export/export default                     |      |          |            |
|   导入    |                   require()                   |                       import/import()                        |      |          |            |
|  值类型   |              拷贝值（模块缓存）               |                      引用值（实时更新）                      |      |          |            |
| 顶层 this |                module.exports                 |                          undefined                           |      |          |            |
|   环境    |                Node.js（默认）                |               浏览器（需编译）/Node.js（.mjs）               |      |          |            |